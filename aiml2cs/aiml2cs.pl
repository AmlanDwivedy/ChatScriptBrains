#!/usr/bin/perl 
#
# first pass at a aiml2cs converter - contributions welcome

use Cwd;
use XML::Simple;
use Data::Dumper;
use File::Basename;
use File::Find;
use Getopt::Std;

our ( $dbug, $opt_d );

getopts('d') or die( "Error in command line arguements.\n" . &usage() );

my $startDir = getcwd();
my $filename = $ARGV[0];
my $outDir   = $ARGV[1] || "cs";

my $dbug = $opt_d || undef;

{
    if ( -d $filename ) {
        print "Processing files in $filename...\n";
        finddepth( \&convertFile, $filename );
    }
    elsif ( -f $filename ) {
        $_ = $filename;
        &convertFile($filename);
    }
}

# this parses the file and sets metadata, then splits it into multiple .top files if there are multiple topics
# not sure if that is right approach, but let's start there.
sub convertFile {
    my $_filename = $_;

    # only convert .aiml files
    if ( !( $_filename =~ m/^.*\.aiml$/ ) ) { return; }

    my ( $name, $path, $suffix ) = fileparse($_filename);
    my ( $topic, $extension, @junk ) = split( /\./, $name );
    print "processing $_...\n";

    my $aiml = XMLin($_filename);

    print Dumper($aiml) if $dbug;

    # is there a topic tag, or more than one?
    if ( $aiml->{topic} ) {
        print "topic $aiml->{topic}->{name} in $_filename detected, setting stuff and stripping it.. " . ref($aiml) . "\n";
        if ( ref( $aiml->{topic} ) eq "HASH" && !$aiml->{topic}->{name} ) {
            print " multiple topics detected, creating a .top file for each one. \n";
            foreach my $topicName ( keys( %{ $aiml->{topic} } ) ) {
                $topic = $topicName;
                print " one topic $topic found, creating one $topic.top file.\n";
                &convertTopic( $_filename, $topic, $aiml->{topic}->{$topicName} );
            }
        }
        else {
            $topic = $aiml->{topic}->{name};
            print " one topic $topic found, creating one $topic.top file.\n";

            # I believe there is no other characteristic of the topic tag?
            # so...  hacky, I know...
            &convertTopic( $_filename, $topic, $aiml->{topic} );
        }
    }
    else {
        print " no topics found, creating $topic-aiml.top file.\n";
        &convertTopic( $_filename, $topic, $aiml );
    }
}

sub convertTopic {
    my ( $file, $top, $aiml, @junk ) = @_;

    my $out = "# Generated by aiml2cs.pl\n";
    $out .= "#  https://github.com/tkuebler/ChatScriptBrains\n\n";
    $out .= "#\n# $file -> $top.top\n#\n";
    $out .= "TOPIC: ~$top" . "aiml (aimlkey) \n\n";

    if ( ref( $aiml->{category} ) ne "ARRAY" ) {
        print "only one category, need to make it look like array anyway\n";
        $aiml->{category} = [ $aiml->{category} ];    # another hack - probably can do this better with xmlin opts..
    }

    foreach my $category ( @{ $aiml->{category} } ) {

        # 	"http://www.chatbots.org/ai_zone/viewthread/1466/""
        #
		# 	1. convert all upper case to lower case this will be flawed for words which are actually proper names
        # 	2. convert the AIML pattern of   word * word * word to u: (< word * word >)
        # 	3. convert the AIML pattern of * word * word * word to u: ( word * word * word >)
        # 	and so on, for all the sentence boundary forms.
        # 	4. for aiml output that is just words, put them on the chatscript output side.
        # 	5. to map other functions of aiml output, you have to handle that on a function decode by function decode basis.

        my $pattern = lc $category->{pattern};
        $pattern = &capIt($pattern);
        my $test    = $pattern;
        $test =~ s/\*/TEST/g;
        $test =~ s/\_/ERROR/g;       # don't know what this is in aiml yet..
        $pattern =~ s/\_/ERROR/g;    # don't know what this is in aiml yet..

        # not working, do later -tk
        #	$pattern =~ s/(.*)\*(.*)\*(.*)/<$1*$2*$3>/g; 		# 2
        #	$pattern =~ s/(.*)\*(.*)\*(.*)\*/<$1*$2*$3*/g;		# 3
        #	$pattern =~ s/\*(.*)\*(.*)\*(.*)/*$1*$2*$3*>/g;		# 3
        #	$pattern =~ s/(.*)\*(.*)/<$1*$2>/g; 		# 2
        #	$pattern =~ s/(.*)\*(.*)\*/<$1*$2*/g;		# 3
        #	$pattern =~ s/\*(.*)\*(.*)/*$1*$2>/g;		# 3
        $pattern =~ s/ +/ /g;

        #handle the bot element for now TODO: resolve the meaning, put in place, continue
        if ( $category->{template}->{bot} ) {
            if ( ref( $category->{template}->{bot} ) eq "ARRAY" ) {
                foreach my $bot ( @{ $category->{template}->{bot} } ) {
                    $out .= "# bot element, not supported yet";
                    $out .= commentedString($bot);
                }
            }
            elsif ( $category->{template}->{bot}->{name} && ref( $category->{template}->{bot}->{name} ) eq "" ) {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) $category->{template}->{bot}->{name}\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }

        #handle the get element TODO: resolve the meaning, put in place, continue
        if ( $category->{template}->{get} ) {
            if ( ref( $category->{template}->{get}->{name} ) eq "" ) {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) $category->{template}->{get}->{name}\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }

        #handle the sri element TODO: resolve the meaning, put in place, continue
        elsif ( $category->{template}->{srai} ) {
            if ( $category->{template}->{srai}->{content}
                && ref( $category->{template}->{srai}->{content} ) eq "" )
            {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) \^reuse($category->{template}->{srai}->{content})\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }
        elsif ( $category->{template}->{random} ) {
            $out .= "#! $test\n";
            $out .= "u: ($pattern) ";
            foreach my $li ( @{ $category->{template}->{random}->{li} } ) {
                if ( ref($li) eq "" ) {
                    $li =~ s/[\(\)\[\]\{\}\:\"\']//g;
                    $out .= "[$li]\n";
                }
                else {
                    $out .= "# li: $li \n";
                }
            }
            $out .= "\n";
        }
        elsif ( $category->{template}->{content} ) {
            $ref = ref( $category->{template}->{content} );

            if ( $ref eq "" ) {
                #my $content = $category->{template}->{content}[0];
                my $content = $category->{template}->{content};
                $content =~ s/[\(\)\[\]\{\}\:\"\']//g;
                $out .= "#! $test\n";
                 my ( $name, $value );
                if ( $category->{template}->{set} ) {
                    # TODO: encorporate
                    ($name, $value, @junk) = @{parseSet( $category->{template}->{set} )};
                }
                $out .= "u: \($pattern\) $value $content\n";
                # \$$name = $value\n";
            }
            else {
                $out .= "# unable to translate ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }
        elsif ( $category->{template} && ref( $category->{template} ) eq "" ) {
            my $template = $category->{template};
            if ( $template->{set} ) {
                parseSet( $template->{set} );
            }
            $template =~ s/[\(\)\[\]\{\}\:\"\']//g;
            $out .= "#! $test\n";
            $out .= "u: \($pattern\) $template\n";
        }
        else {
            $out .= "# unable to translate ($pattern) match to cs rule - see struc below\n";
            $out .= "# " . commentedString( \$category->{template} ) . "\n";
        }

    }
    $out .= "# main gambits\n";
	
    # using ^mark(generalresponder)  in main control script instead, way better.
    #$out .= "t: [Would you like to talk about $top?][I'd like to talk about $top.][What do you think about $top?]\n\n";

    my $of = "$startDir/$outDir\/$top-aiml\.top";
    print " writing to: $of from " . getcwd() . "\n" if $dbug;
    open( my $fh, '>', "$of" ) or die "Can't open $of for writing - $!\n";
    print $fh $out;
}

sub capIt() {
	my ($pattern, @junk) = @_;
	open( my $fh, '<', "$startDir/capit.txt") or die "Can't open capit.txt for reading - $!\n";
	while ( <$fh> ) {
		chomp;
		$pattern =~ s/\Q$_\E/$_/gi;
	}
	return $pattern;
}
sub parseSet() {
    my ( $setTag, @junk ) = @_;
    print "Set tag found.." . Dumper( \$setTag ) . "\n";
    return [ $setTag->{name}, $setTag->{content} ];
}

sub commentedString() {
    my ( $inref, @junk ) = @_;
    if ($dbug) { print "-tk commentedString : " . ref($inref) . ", @junk.\n"; }
    my @inStr = split( '\n', Dumper($inref) );
    my $outStr = "# TODO: fix this raw AIML element data structure\n";
    foreach my $line (@inStr) {
        $outStr .= "# " . $line . "\n";
    }
    return $outStr;
}

sub usage {
    return "\naiml2cs.pl [-d] [-od output directory] [-id input directory] [-f file]\n";
}
