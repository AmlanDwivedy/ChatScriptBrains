#!/usr/bin/perl 
#
# first pass at a aiml2cs converter - contributions welcome

use Cwd;
use XML::Simple;
use Data::Dumper;
use File::Basename;
use File::Find;
use Getopt::Long;

my $startDir = getcwd();
my $filename = $ARGV[0];
my $outDir   = "cs";
my $dbug;

if ( -d $filename ) {
    print "Processing files in $filename...\n";
    finddepth( \&convertFile, $filename );
}
elsif ( -f $filename ) {
    $_ = $filename;
    &convertFile($filename);
}

sub convertFile {
    my $_filename = $_;

    my ( $name, $path, $suffix ) = fileparse($_filename);
    my ( $topic, $extension, @junk ) = split( /\./, $name );
    print "processing $_...\n";

    my $aiml = XMLin($_filename);

    print Dumper($aiml) if $dbug;

    my $out = "# Generated by aiml2cs.pl\n";
    $out .= "#  https://github.com/tkuebler/ChatScriptBrains\n\n";
    $out .= "TOPIC: ~$topic-aiml (~$topic) \n\n";

    foreach my $category ( @{ $aiml->{category} } ) {

        # 	http://www.chatbots.org/ai_zone/viewthread/1466/
        #
        # 	1. convert all upper case to lower caseâ€”this will be flawed for words which are actually proper names
        # 	2. convert the AIML pattern of   word * word * word to u: (< word * word >)
        # 	3. convert the AIML pattern of * word * word * word to u: ( word * word * word >)
        # 	and so on, for all the sentence boundary forms.
        # 	4. for aiml output that is just words, put them on the chatscript output side.
        # 	5. to map other functions of aiml output, you have to handle that on a function decode by function decode basis.

        my $pattern = lc $category->{pattern};
        my $test    = $pattern;
        $test =~ s/\*/TEST/g;
        $test =~ s/\_/ERROR/g;       # don't know what this is in aiml yet..
        $pattern =~ s/\_/ERROR/g;    # don't know what this is in aiml yet..

        # not working, do later -tk
        #	$pattern =~ s/(.*)\*(.*)\*(.*)/<$1*$2*$3>/g; 		# 2
        #	$pattern =~ s/(.*)\*(.*)\*(.*)\*/<$1*$2*$3*/g;		# 3
        #	$pattern =~ s/\*(.*)\*(.*)\*(.*)/*$1*$2*$3*>/g;		# 3
        #	$pattern =~ s/(.*)\*(.*)/<$1*$2>/g; 		# 2
        #	$pattern =~ s/(.*)\*(.*)\*/<$1*$2*/g;		# 3
        #	$pattern =~ s/\*(.*)\*(.*)/*$1*$2>/g;		# 3
        $pattern =~ s/ +/ /g;

        #handle the bot element for now TODO: resolve the meaning, put in place, continue
        if ( $category->{template}->{bot} ) {
            if ( ref( $category->{template}->{bot} ) eq "ARRAY" ) {
                foreach my $bot ( @{ $category->{template}->{bot} } ) {
                    $out .= "# bot element, not supported yet";
                    $out .= commentedString($bot);
                }
            }
            elsif ( $category->{template}->{bot}->{name} && ref( $category->{template}->{bot}->{name} ) eq "" ) {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) $category->{template}->{bot}->{name}\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }

        #handle the get element TODO: resolve the meaning, put in place, continue
        if ( $category->{template}->{get} ) {
            if ( ref( $category->{template}->{get}->{name} ) eq "" ) {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) $category->{template}->{get}->{name}\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }

        #handle the sri element TODO: resolve the meaning, put in place, continue
        elsif ( $category->{template}->{srai} ) {
            if ( $category->{template}->{srai}->{content}
                && ref( $category->{template}->{srai}->{content} ) eq "" )
            {
                $out .= "#! $test\n";
                $out .= "u: ($pattern) \^reuse($category->{template}->{srai}->{content})\n";
            }
            else {
                $out .= "# unable to translate  ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }
        elsif ( $category->{template}->{random} ) {
            $out .= "#! $test\n";
            $out .= "u: ($pattern) ";
            foreach my $li ( @{ $category->{template}->{random}->{li} } ) {
                if ( ref($li) eq "" ) {
                    $out .= "[$li]\n";
                }
                else {
                    $out .= "# li: $li \n";
                }
            }
            $out .= "\n";
        }
        elsif ( $category->{template}->{content} ) {
            $ref = ref( $category->{template}->{content} );
            if ( $ref eq "" ) {
                $out .= "#! $test\n";
                $out .= "u: \($pattern\) $category->{template}->{content}[0]\n";
            }
            else {
                $out .= "# unable to translate ($pattern) match to cs rule - see struc below\n";
                $out .= "# " . commentedString( \$category->{template} ) . "\n";
            }
        }
        elsif ( $category->{template} && ref( $category->{template} ) eq "" ) {
            $out .= "#! $test\n";
            $out .= "u: \($pattern\) $category->{template}\n";
        }
        else {
            $out .= "# unable to translate ($pattern) match to cs rule - see struc below\n";
            $out .= "# " . commentedString( \$category->{template} ) . "\n";
        }

    }

    my $of = "$startDir/$outDir\/$topic-aiml\.top";
    print " writing to: $of from " . getcwd() . "\n" if $dbug;
    open( my $fh, '>', "$of" ) or die "Can't open $of for writing - $!\n";
    print $fh $out;
}

sub commentedString() {
    my ( $inref, @junk ) = @_;
    if ($dbug) { print "-tk commentedString : " . ref($inref) . ", @junk.\n"; }
    my @inStr = split( '\n', Dumper($inref) );
    my $outStr = "# TODO: fix this raw AIML element data structure\n";
    foreach my $line (@inStr) {
        print "got here a -tk\n" if $dbug;
        $outStr .= "# " . $line . "\n";
        print "got here b -tk\n" if $dbug;
    }
    return $outStr;
}

$out .= "# main gambits\n";
$out .= "t: [Would you like to talk about $topic?][I'd like to talk about $topic.][What do you think about $topic?]\n\n";

print $out;
